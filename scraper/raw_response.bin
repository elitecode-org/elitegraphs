{"submissions_dump":[{"id":1462545247,"question_id":747,"lang":"python3","lang_name":"Python3","time":"5 days, 8 hours","timestamp":1732548862,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1462545247/","is_pending":"Not Pending","title":"Min Cost Climbing Stairs","memory":"16.7 MB","code":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n\n\n        dp = [0] * len(cost)\n        \n        stairs = len(cost)\n        for i in range(stairs-1, -1, -1):\n\n            if i == stairs - 1 or i == stairs - 2:\n                dp[i] = cost[i]\n                continue\n\n            if dp[i + 1] > dp[i + 2]:\n                dp[i] = cost[i] + dp[i + 2]\n            else:\n                dp[i] = cost[i] + dp[i + 1]\n\n        return min(dp[0], dp[1])\n\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"min-cost-climbing-stairs","has_notes":false,"flag_type":1},{"id":1452709669,"question_id":70,"lang":"python3","lang_name":"Python3","time":"2 weeks, 2 days","timestamp":1731599305,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1452709669/","is_pending":"Not Pending","title":"Climbing Stairs","memory":"16.6 MB","code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n\n    # 1 stair = 1 way\n    # 2 stairs = 2 ways\n    # 3 stairs = (take 1 step + sum of 2 stairs) + take 2 steps + sum of 1 stairs)\n    # 3 stairs = (take 1 step + sum of 3-1 stairs) + take 2 steps + sum of 3-2 stairs\n    # n stairs = (take 1 step + sum of n-1 stairs)+ take 2 steps + sum of n-2 stairs\n    # n stairs = n-1 + n-2\n\n        if n == 1:\n            return 1\n        if n == 2: \n            return 2\n\n        dp = [0] * (n + 1) # bc we ignore the 0 index, shift right\n\n        dp[1] = 1\n        dp[2] = 2\n\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[n]\n\n\n\n\n","compare_result":"111111111111111111111111111111111111111111111","title_slug":"climbing-stairs","has_notes":false,"flag_type":1},{"id":1452709131,"question_id":70,"lang":"python3","lang_name":"Python3","time":"2 weeks, 2 days","timestamp":1731599266,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1452709131/","is_pending":"Not Pending","title":"Climbing Stairs","memory":"N/A","code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n\n    # 1 stair = 1 way\n    # 2 stairs = 2 ways\n    # 3 stairs = (take 1 step + sum of 2 stairs) + take 2 steps + sum of 1 stairs)\n    # 3 stairs = (take 1 step + sum of 3-1 stairs) + take 2 steps + sum of 3-2 stairs\n    # n stairs = (take 1 step + sum of n-1 stairs)+ take 2 steps + sum of n-2 stairs\n    # n stairs = n-1 + n-2\n\n        dp = [0] * (n + 1) # bc we ignore the 0 index, shift right\n\n        dp[1] = 1\n        dp[2] = 2\n\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[n]\n\n\n\n\n","compare_result":"110000000000000000000000000000000000000000000","title_slug":"climbing-stairs","has_notes":false,"flag_type":1},{"id":1450671356,"question_id":417,"lang":"python3","lang_name":"Python3","time":"2 weeks, 4 days","timestamp":1731423068,"status":10,"status_display":"Accepted","runtime":"31 ms","url":"/submissions/detail/1450671356/","is_pending":"Not Pending","title":"Pacific Atlantic Water Flow","memory":"18.4 MB","code":"class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n\n        directions = [[1,0],[0,1],[-1,0],[0,-1]]\n        ROWS = len(heights)\n        COLS = len(heights[0])\n\n        pacific = set()\n        atlantic = set()\n\n        def dfs(r, c, reachable):\n            reachable.add((r, c))\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if (nr, nc) in reachable:\n                    continue\n                if 0 <= nr < ROWS and 0 <= nc < COLS and heights[nr][nc] >= heights[r][c]:\n                    dfs(nr, nc, reachable)\n\n        for r in range(ROWS):\n            dfs(r, 0, pacific)\n            dfs(r, COLS - 1, atlantic)\n        \n        for c in range(COLS):\n            dfs(0, c, pacific)\n            dfs(ROWS - 1, c, atlantic)\n\n        res = pacific & atlantic\n        return [list(cell) for cell in res]\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"pacific-atlantic-water-flow","has_notes":false,"flag_type":1},{"id":1449715280,"question_id":1036,"lang":"python3","lang_name":"Python3","time":"2 weeks, 5 days","timestamp":1731342196,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1449715280/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"16.7 MB","code":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        \n        # iterate through grid and store oranges in rotting set and fresh set\n        directions = [[1,0],[-1,0],[0,-1],[0,1]]\n        ROWS, COLS, = len(grid), len(grid[0])\n        fresh = set()\n        q = deque()\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 2:\n                    q.append((r, c))\n                if grid[r][c] == 1:\n                    fresh.add((r, c))\n        \n        if not fresh:\n            return 0\n\n        mins = 0\n        while q and fresh:\n            for _ in range(len(q)):\n                row, col = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = row + dr, col + dc\n                    if (nr, nc) in fresh:\n                        fresh.remove((nr, nc))\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n            mins += 1\n        return -1 if fresh else mins\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges","has_notes":false,"flag_type":1},{"id":1447792415,"question_id":695,"lang":"python3","lang_name":"Python3","time":"3 weeks","timestamp":1731167564,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1447792415/","is_pending":"Not Pending","title":"Max Area of Island","memory":"16.9 MB","code":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        \n        directions = [[1,0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        maxArea = 0\n\n        def bfs(r, c):\n            q = deque()\n            grid[r][c] = 0\n            q.append((r, c))\n            count = 1\n        \n            while q:\n                row, col = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = dr + row, dc + col\n\n                    if (nr < 0 or nc < 0 or nr >= ROWS or nc >= COLS or grid[nr][nc] == 0):\n                        continue\n                    count += 1\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n            \n            return count\n\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1:\n                    maxArea = max(bfs(r, c), maxArea)\n\n        return maxArea\n\n\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"max-area-of-island","has_notes":false,"flag_type":1},{"id":1447764091,"question_id":200,"lang":"python3","lang_name":"Python3","time":"3 weeks","timestamp":1731166383,"status":10,"status_display":"Accepted","runtime":"221 ms","url":"/submissions/detail/1447764091/","is_pending":"Not Pending","title":"Number of Islands","memory":"19 MB","code":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        islands = 0\n\n        # dfs solution:\n        # def dfs(r, c):\n\n        #     if (r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == \"0\"):\n        #         return\n\n        #     grid[r][c] = \"0\"\n\n        #     for dr, dc in directions:\n        #         dfs(r + dr, c + dc)\n\n        \n        # for r in range(ROWS):\n        #     for c in range(COLS):\n        #         if grid[r][c] == \"1\":\n        #             dfs(r, c)\n        #             islands += 1\n\n        # bfs solution:\n\n        def bfs(r, c):\n            q = deque()\n            grid[r][c] = \"0\"\n            q.append((r, c))\n\n            while q:\n                row, col = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = dr + row, dc + col\n                    if (nr < 0 or nc < 0 or nr >= ROWS or nc >= COLS or grid[nr][nc] == \"0\"):\n                        continue\n                    q.append((nr, nc))\n                    grid[nr][nc] = \"0\"\n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == \"1\":\n                    bfs(r, c)\n                    islands += 1\n\n        return islands","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"number-of-islands","has_notes":false,"flag_type":1},{"id":1447763573,"question_id":200,"lang":"python3","lang_name":"Python3","time":"3 weeks","timestamp":1731166363,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1447763573/","is_pending":"Not Pending","title":"Number of Islands","memory":"N/A","code":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        islands = 0\n\n        # dfs solution:\n        # def dfs(r, c):\n\n        #     if (r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == \"0\"):\n        #         return\n\n        #     grid[r][c] = \"0\"\n\n        #     for dr, dc in directions:\n        #         dfs(r + dr, c + dc)\n\n        \n        # for r in range(ROWS):\n        #     for c in range(COLS):\n        #         if grid[r][c] == \"1\":\n        #             dfs(r, c)\n        #             islands += 1\n\n        # bfs solution:\n\n        def bfs(r, c):\n            q = deque()\n            grid[r][c] = \"0\"\n            q.append((r, c))\n\n            while q:\n                row, col = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = dr + row, dc + col\n                    if (nr < 0 or nc < 0 or nr >= ROWS or nc >= COLS or grid[nr][nc] == \"0\"):\n                        continue\n                    q.append((nc, nr))\n                    grid[nr][nc] = \"0\"\n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == \"1\":\n                    bfs(r, c)\n                    islands += 1\n\n        return islands","compare_result":"1111111111011111111100010110011001000001001001000","title_slug":"number-of-islands","has_notes":false,"flag_type":1},{"id":1447761937,"question_id":200,"lang":"python3","lang_name":"Python3","time":"3 weeks","timestamp":1731166302,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1447761937/","is_pending":"Not Pending","title":"Number of Islands","memory":"N/A","code":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        islands = 0\n\n        # dfs solution:\n        # def dfs(r, c):\n\n        #     if (r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == \"0\"):\n        #         return\n\n        #     grid[r][c] = \"0\"\n\n        #     for dr, dc in directions:\n        #         dfs(r + dr, c + dc)\n\n        \n        # for r in range(ROWS):\n        #     for c in range(COLS):\n        #         if grid[r][c] == \"1\":\n        #             dfs(r, c)\n        #             islands += 1\n\n        # bfs solution:\n\n        def bfs(r, c):\n            q = deque()\n            grid[r][c] == \"0\"\n            q.append((r, c))\n\n            while q:\n                row, col = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = dr + row, dc + col\n                    if (nr < 0 or nc < 0 or nr >= ROWS or nc >= COLS or grid[nr][nc] == \"0\"):\n                        continue\n                    q.append((nc, nr))\n                    grid[nr][nc] = \"0\"\n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == \"1\":\n                    bfs(r, c)\n                    islands += 1\n\n        return islands","compare_result":"1111111111011111111100010110011001000001001001000","title_slug":"number-of-islands","has_notes":false,"flag_type":1},{"id":1447745124,"question_id":200,"lang":"python3","lang_name":"Python3","time":"3 weeks","timestamp":1731165672,"status":10,"status_display":"Accepted","runtime":"226 ms","url":"/submissions/detail/1447745124/","is_pending":"Not Pending","title":"Number of Islands","memory":"19.2 MB","code":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n        ROWS, COLS = len(grid), len(grid[0])\n\n        islands = 0\n\n        def dfs(r, c):\n\n            if (r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == \"0\"):\n                return\n\n            grid[r][c] = \"0\"\n\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == \"1\":\n                    dfs(r, c)\n                    islands += 1\n                    \n        return islands","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"number-of-islands","has_notes":false,"flag_type":1},{"id":1441974342,"question_id":812,"lang":"python3","lang_name":"Python3","time":"3 weeks, 6 days","timestamp":1730656106,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1441974342/","is_pending":"Not Pending","title":"Rotate String","memory":"16.7 MB","code":"class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n\n\n        # Check if the lengths are different (can't be rotations if they are)\n        if len(s) != len(goal):\n            return False\n        \n        # Check if goal is a substring of s + s\n        return goal in (s + s)\n\n\n            \n\n\n            ","compare_result":"111111111111111111111111111111111111111111111111111111","title_slug":"rotate-string","has_notes":false,"flag_type":1},{"id":1441918145,"question_id":79,"lang":"python3","lang_name":"Python3","time":"3 weeks, 6 days","timestamp":1730652177,"status":10,"status_display":"Accepted","runtime":"3384 ms","url":"/submissions/detail/1441918145/","is_pending":"Not Pending","title":"Word Search","memory":"16.6 MB","code":"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \n\n        def dfs(r, c, n):\n\n            if n == len(word):\n                return True\n\n            if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]) or board[r][c] != word[n]:\n                return False\n            \n            temp = board[r][c]\n            board[r][c] = \"#\"\n\n            found = (dfs(r - 1, c, n + 1) or \n                     dfs(r + 1, c, n + 1) or  \n                     dfs(r, c - 1, n + 1) or  \n                     dfs(r, c + 1, n + 1))    \n\n            board[r][c] = temp\n            return found\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n\n        return False","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"word-search","has_notes":false,"flag_type":1},{"id":1438259508,"question_id":40,"lang":"python3","lang_name":"Python3","time":"1 month","timestamp":1730299212,"status":10,"status_display":"Accepted","runtime":"31 ms","url":"/submissions/detail/1438259508/","is_pending":"Not Pending","title":"Combination Sum II","memory":"16.9 MB","code":"class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        res = []\n        cur = []\n        candidates.sort()\n\n        def dfs(i, total):\n\n            if total == target:\n                res.append(cur.copy())\n                return\n\n            if i >= len(candidates) or total > target:\n                return\n            \n            cur.append(candidates[i])\n            dfs(i + 1, total + candidates[i])\n            cur.pop()\n\n            while i + 1 < len(candidates) and candidates[i] == candidates[i + 1]:\n                i += 1\n\n            dfs(i + 1, total)\n\n        dfs(0, 0)\n        return res","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"combination-sum-ii","has_notes":false,"flag_type":1},{"id":1436262026,"question_id":90,"lang":"python3","lang_name":"Python3","time":"1 month","timestamp":1730124683,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1436262026/","is_pending":"Not Pending","title":"Subsets II","memory":"17.1 MB","code":"class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        \n        res = []\n        cur = []\n        check = set()\n\n        def dfs(i):\n            if i >= len(nums):\n                sorted_cur = tuple(sorted(cur))\n                if sorted_cur not in check:\n                    res.append(cur.copy())\n                    check.add(sorted_cur)\n                return\n\n            cur.append(nums[i])\n            dfs(i + 1)\n\n            cur.pop()\n            dfs(i + 1)\n\n        dfs(0)\n        return res\n            ","compare_result":"11111111111111111111","title_slug":"subsets-ii","has_notes":false,"flag_type":1},{"id":1434720216,"question_id":46,"lang":"python3","lang_name":"Python3","time":"1 month","timestamp":1729989755,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1434720216/","is_pending":"Not Pending","title":"Permutations","memory":"16.9 MB","code":"class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \n        res = []\n        cur = []\n        s = set()\n\n        def dfs():\n            \n            if len(cur) == len(nums):\n                res.append(cur.copy())\n                return  \n\n            for num in nums:\n                if num not in s:\n                    cur.append(num)\n                    s.add(num)\n                    dfs()\n                    s.remove(num)\n                    cur.pop()\n        dfs()\n        return res","compare_result":"11111111111111111111111111","title_slug":"permutations","has_notes":false,"flag_type":1},{"id":1431469482,"question_id":39,"lang":"python3","lang_name":"Python3","time":"1 month, 1 week","timestamp":1729691723,"status":10,"status_display":"Accepted","runtime":"13 ms","url":"/submissions/detail/1431469482/","is_pending":"Not Pending","title":"Combination Sum","memory":"16.5 MB","code":"class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            \n            if i >= len(candidates) or total > target:\n                return\n\n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n\n        dfs(0, [], 0)\n        return res","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"combination-sum","has_notes":false,"flag_type":1},{"id":1429366502,"question_id":1715,"lang":"python3","lang_name":"Python3","time":"1 month, 1 week","timestamp":1729519185,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1429366502/","is_pending":"Not Pending","title":"Split a String Into the Max Number of Unique Substrings","memory":"N/A","code":"class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        res = set()\n        st = \"\"\n\n        for i in range(len(s)):\n            st += s[i]\n            if st in res:\n                continue\n            res.add(st)\n            st = \"\"\n            \n        return len(res) ","compare_result":"11111111111111111111111110111111010111111110111011011101110110110111110111100111111001110101001","title_slug":"split-a-string-into-the-max-number-of-unique-substrings","has_notes":false,"flag_type":1},{"id":1428327930,"question_id":1975,"lang":"python3","lang_name":"Python3","time":"1 month, 1 week","timestamp":1729427703,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1428327930/","is_pending":"Not Pending","title":"Minimum Distance to the Target Element","memory":"16.7 MB","code":"class Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        \n\n        l = 0\n        r = len(nums) - 1\n    \n        minL = len(nums)\n\n        if nums[start] == target:\n            return 0\n\n        while l != r:\n\n            if l != start:\n                if nums[l] == target:\n                    minL = min(minL, abs(l - start))\n                l += 1\n\n            if r != start:\n                if nums[r] == target:\n                    minL = min(minL, abs(r - start))\n                r -= 1\n            \n            if l == start and r == start:\n                return minL\n            ","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-distance-to-the-target-element","has_notes":false,"flag_type":1},{"id":1427295139,"question_id":1667,"lang":"python3","lang_name":"Python3","time":"1 month, 1 week","timestamp":1729343202,"status":10,"status_display":"Accepted","runtime":"411 ms","url":"/submissions/detail/1427295139/","is_pending":"Not Pending","title":"Find Kth Bit in Nth Binary String","memory":"25.9 MB","code":"class Solution:\n    def findKthBit(self, n: int, k: int) -> str:\n\n        def reverse(s):\n            return s[::-1]\n\n        def inverse(s):\n            return ''.join('1' if bit == '0' else '0' for bit in s)\n\n        def find(num):\n            if num == 1:\n                return \"0\"\n            prev = find(num - 1)\n            new = prev + \"1\" + reverse(inverse(prev))\n            return new\n\n        word = find(n)\n        return word[k - 1]","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-kth-bit-in-nth-binary-string","has_notes":false,"flag_type":1},{"id":1426376372,"question_id":138,"lang":"python3","lang_name":"Python3","time":"1 month, 1 week","timestamp":1729256476,"status":10,"status_display":"Accepted","runtime":"37 ms","url":"/submissions/detail/1426376372/","is_pending":"Not Pending","title":"Copy List with Random Pointer","memory":"17.4 MB","code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n\n        if not head:\n            return None\n\n        cur = head\n        while cur:\n            new = Node(cur.val)\n            new.next = cur.next\n            cur.next = new\n            cur = new.next\n\n        cur = head\n        while cur:\n            if cur.random:\n                cur.next.random = cur.random.next  # Set copied node's random\n            cur = cur.next.next\n\n        cur = head\n        copy_head = head.next\n        copy_cur = copy_head\n        \n        while cur:\n            cur.next = cur.next.next  # Restore original list\n            if copy_cur.next:\n                copy_cur.next = copy_cur.next.next  # Set next for copied list\n            cur = cur.next\n            copy_cur = copy_cur.next\n        \n        return copy_head\n        \n\n\n","compare_result":"1111111111111111111","title_slug":"copy-list-with-random-pointer","has_notes":false,"flag_type":1}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221426376372%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222024-10-18T13%3A01%3A16.842288%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227412020%22%7D%7D"}